									EXPLANATION OF EACH CODE
									------------------------

(We apologize for some of the names of certain functions being in Spanish. We hope with the explanation you can understand what each one of those does.)

DISCLAIMER: Some of the parts of the task are still under testing and improving. Therefore, we will only include what has been fully tested and is fully operating. This means most of the rescue area functions will not appear.

--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

	ARDUINO			
	-------

-> Void Setup()
We set the serial communication to 115200 baud and make the servos go to their 'stand by' position (the claw is up and closed). The, we set the Time of Flight sensors to a specific I2C direction in order to be able to use them


-> Void Loop()
It is divided in two parts:
 a) Reading:
It reads everything it is receiving from Lego Spike until '\n', which is used to separate messages. Then, depending on the message, the Arduino changes a boolean state that indicates what the board should do next.

 b) Writing:
Depending on the boolean state that is chosen, the Arduino will perform a certain task:
 - If it gets the state 'Seguidor' ('line-follower), it will return 'A' or 'F', taking into account if there is anything blocking the way, such as an obstacle or a wall.
 - If it gets the state 'Obstacle', the Arduino will return different letters depending on how close the robot is to the obstacle or to a wall that might be blocking the way while trying to avoid it. 
 - If it gets the state 'Rescue', it will return different letters according to the distances. It will also get substates depending on what the robot is doing: picking the ball up, depositing ball or cube, or just exploring.
 - On the other hand, if it receives an order, the board will operate the servos and do what the order says.

--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

         LEGO
         ----

-> Initialization()
We set the 'E' Port to (FULL_DUPLEX) to a 115200 baud rate, just like we do with Arduono. We then define the ports of the motors and sensors, as well as the variables that are going to be used for PID controller.

-> FUNCTIONS
a) Update(): It updates the color sensor values and defines the silver and the greens. This is necessary because we are use using RGB values in the sensors in order to be more precise when it comes to detecting different colors.

b) Giros(): Turns to one side or the other depending on the number of angles we specify as a parameter.

c) Verde(): It reverses and then turns a bit to verify there is not a dead end. If this does not happen, the robot turns to the correspondent side and continues turning until it finds the line back again and continues with the exercise.

d) Doble Negro(): It reverses and checks if there is not a green behind that could have possibly went past without noticing. If this is the case, it continues with the correspondent part of the code for the green tapes. However, if it verifies it is standing in front of a double black, it goes forward a bit and overcomes this part of the task.

e) Subida(): Depending on the inclination detected by the Spike gyroscope (in this case, the inclination is positive), it will, firstly, go forward and send the order to Lower the claw to the Arduino Nano, so that the robot can climb the ramp or seesaw smoothly and without complications. While the robot is climbing the ramp or seesaw, it will still follow the line using PID controller. This function will keep the claw up until the gyroscope detects that the inclination has decreased. When this happens, the claw will be lowered using the following function.

f) Bajada(): If the gyroscope detects a negative inclination, the robot will reverse to the flat area to avoid falling and will send the order of lowering the claw, so that it can be used as a support for the robot. While it is climbing down the ramp, it is still following the line using PID. However, the proportional values are lowered, in an attempt to avoid clumsy turns. When the gyro detects that the robot is on a flat surface, it lifts the claw back again.

g) Obstaculo(): It sends the state 'obstacle' to the Arduino, and waits for the letters that indicate the distance that the ToFs are measuring. The robot will get as close as 5cm to the obstacle, identify the line, reverse and then turn right. After turning, it asks if there is a wall blocking the way. If there is, then it avoids the obstacle by surrounding them on the other side. If not, it avoids the obstacle by surrounding them on the right.


-> While True()
Contains the function 'update()', in order to keep the sensors updated all the time. It is also responsible for the PID mathematical operations. If it detects the silver tape, it starts the 'rescue' part of the code; if it detects any sort of inclination, it will rather enter 'Subida()' or 'Bajada()'. During this While True(), the Lego will constantly read the sensors and be aware of green tapes or double black, while still telling the Arduino which state the Lego is in. Also, there is a function that is always reading the buffer, in case the Arduino sends a message warning about something blocking the way. 

The main part of the While True() is the line-following part. The PID controller will be asking for the sensors values, being the proportional coefficient directly proportional to the intensity of the reflected light of the color sensors.








